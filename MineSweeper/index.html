<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>ì§€ë¢°ì°¾ê¸°</title>
    <style>
        body{
            padding: 50px;
            text-align: center;
        }
        table{
            border: 15px solid #DDD;
            border-collapse: collapse;
            margin: 0 auto;
        }
        td{
            padding:0;
            margin:0;
            border-spacing: 0;
            border:1px solid #DDD;
            border-collapse: collapse;
            height:40px;
            width:40px;
            text-align: center;
            cursor:pointer;
        }

        .bomb{
            background-color: red;
            /*color:#FFF;*/
        }
        .opened{
            background-color: #EEE;
            font-weight: bold;
            color:green;
        }
        .flagged{

        }
        #game-status{
            font-weight: bold;
            font-size: 2rem;
        }
    </style>
</head>
<body>
    <table>
        <tbody id="board"></tbody>
    </table>
    <p id="game-status"></p>
<script>

    /* ê²Œì„ ì„¸íŒ… */
    const BW = 10;
    const BH = 12;
    const bombCnt = 3;
    const cellCnt = BW * BH;




    /* ì§€ë¢° ì •ë³´ */

    let bombArr = [];

    (() =>{
        let tempArr = [];
        for(let i = 0; i < cellCnt; i++){
            tempArr[i] = i;
        }
        for(let i = 0; i < bombCnt; i++){
            const randNum = Math.floor(Math.random() * (cellCnt - i));
            bombArr.push(tempArr[randNum]);
            tempArr.splice(randNum,1);
        }
    })();



    /* ì§€ë¢°ë°­ ì •ë³´ */

    let cellData = new Array(cellCnt);

    (()=>{
        /**
         * ìœ„ì¹˜ íƒ€ì…
         * ëª¨ì„œë¦¬ : ì¢Œìƒ, ìš°ìƒ, ì¢Œí•˜, ìš°í•˜
         * ëª¨ì„œë¦¬ë¥¼ ì œì™¸í•œ ì¤„ ë¼ì¸: ìœ—ì¤„, ì´ë«ì¤„, ì™¼ì¤„, ì˜¤ë¥¸ì¤„
         * ê¸°íƒ€ 9ì¹¸
         */

        const firstRow = 0;
        const firstCol = 0;
        const lastRow = BH-1;
        const lastCol = BW-1;

        let position = '';

        for(let row = 0; row< BH; row ++){

            for(let col = 0; col< BW; col ++){

                const index = row * BW + col;

                if(row === firstRow){
                    if      (col === firstCol)  position = 'TOP_LEFT';
                    else if (col === lastCol)	position = 'TOP_RIGHT';
                    else                        position = 'TOP_LINE';
                }

                else if(row === lastRow){
                    if      (col === firstCol)  position = 'BOTTOM_LEFT';
                    else if (col === lastCol)	position = 'BOTTOM_RIGHT';
                    else                        position = 'BOTTOM_LINE';
                }

                else{
                    if      (col === firstCol)  position = 'LEFT_LINE';
                    else if (col === lastCol)	position = 'RIGHT_LINE';
                    else                        position = 'INSIDE';
                }

                cellData[index] = position;
            }
        }
    })();

    /* ì§€ë¢°ë°­ ìƒì„± */
    const boardTable = document.getElementById('board');

    let boardElement = '';
    (()=>{
        for(let i = 0; i< BH; i ++){
            boardElement +='<tr>';
            for(let j = 0; j< BW; j ++){
                const boxIndex = i*BW + j;
                boardElement +=`<td data-index="${boxIndex}"></td>`;
            }
            boardElement +='</tr>';
        }
        boardTable.innerHTML = boardElement;
    })();

    function cellElement(index) {
        return boardTable.querySelector(`[data-index="${index}"]`);
    }

    function hasClass(index, className) {
        return cellElement(index).classList.contains(className)
    }

    function getSurround(index){

        const position = cellData[index];
        let surround = [];

        const left = index - 1;
        const right = index + 1;
        const over = index - BW;
        const under = index + BW;

        Number.prototype.left = function () {return this - 1};
        Number.prototype.right = function () {return this + 1};

        switch (position) {
            case 'TOP_LEFT' :
                surround = [right, under, under.right()];
                break;

            case 'TOP_RIGHT' :
                surround = [left, under, under.left()];
                break;

            case 'BOTTOM_LEFT' :
                surround = [over, over.right(), right];
                break;

            case 'BOTTOM_RIGHT' :
                surround = [left, over, over.left()];
                break;

            case 'TOP_LINE' :
                surround = [left, right, under, under.left(), under.right()];
                break;

            case 'BOTTOM_LINE' :
                surround = [left, right, over, over.left(), over.right()];
                break;

            case 'LEFT_LINE' :
                surround = [over, over.right(), right, under, under.right()];
                break;

            case 'RIGHT_LINE' :
                surround = [over, over.left(), left, under, under.left()];
                break;

            default :
                surround = [over.left(), over, over.right(), left, right, under.left(), under, under.right()];

        }
        return surround;
    }


    function isBomb(index) {
        return bombArr.some(bombIndex => bombIndex === index)
    }

    let isGameOver = false;
    let isWin = false;

    function gameOver(){
        isGameOver = true;
        let resultText = 'GAME OVER !!';
        if(isWin) {
            resultText = 'You Win';
        }

        document.getElementById('game-status').innerText = resultText;
    }

    function checkIsGameOver (){

        let openedCellCnt = 0;
        let flaggedCellCnt = 0;

        for(let i = 0; i < cellCnt; i++){
            if(hasClass(i,'opened')){openedCellCnt++;}
        }

        for(let i = 0; i < cellCnt; i++){
            if(hasClass(i,'flagged')){flaggedCellCnt++;}
        }

        if(!isGameOver){
            isWin = (flaggedCellCnt === bombArr.length) && bombArr.length + openedCellCnt === cellCnt;
        }

        if(isWin){
            gameOver();
        }

        return(isGameOver);
    }


    /* ìš°í´ë¦­ ì´ë²¤íŠ¸ */
    window.oncontextmenu = (e) =>{
        if(isGameOver) return;
        if( e.target.nodeName !== 'TD' ) return;
        if( e.target.classList.contains('opened') ) return;

        e.preventDefault();
        const selectedCell = e.target;

        let content = 'ğŸš©';
        if(selectedCell.textContent === 'ğŸš©'){
            content = '';
        }
        selectedCell.innerHTML = content;
        selectedCell.classList.toggle('flagged');

        checkIsGameOver();
    };


    /* ì¢Œí´ë¦­ ì´ë²¤íŠ¸ */
    boardTable.addEventListener('click', function(e){
        if(isGameOver)return;
//        if( e.target.classList.contains('opened') ) return;
        if( e.target.classList.contains('flagged') ) return;
        
        const index = Number(e.target.dataset.index);
        cellOpenRequest(index, false);

    });


    function cellOpenRequest(index, isAutoSurroundOpen){

        const selectedCell = cellElement(index);
        if(selectedCell.classList.contains('opened')) return;

        /** ì˜¤í”ˆ ê°€ëŠ¥ ì—¬ë¶€ íŒë‹¨  */
        if(isAutoSurroundOpen && isBomb(index))return; /* ì»´í“¨í„°ì˜ ìš”ì²­(ìë™ ì—°ì‡„ì˜¤í”ˆ)ì´ë©´, í­íƒ„ì…€ì¼ ê²½ìš° ì—´ì§€ ì•ŠìŒ */

        /** ì˜¤í”ˆ ì‹¤í–‰  */

        /* ì§€ë¢°ê°¯ìˆ˜ í™•ì¸ */
        const surroundCells = getSurround(index);
        
        let surroundBombCnt = 0;
        let surroundOpenedCnt = 0;

        surroundCells.forEach(index => {

            if(bombArr.some(bombNum => bombNum === index)){
                surroundBombCnt ++;
            }

            if(hasClass(index, 'opened')){
                surroundOpenedCnt++;
            }
        });


        if(isBomb(index)){
            clickBomb(index);
//            return;
        }else{
            selectedCell.innerHTML = `${surroundBombCnt !== 0 ? surroundBombCnt : '' }`;
            selectedCell.classList.add('opened');
            checkIsGameOver();
        }
        
        const allOpened = surroundBombCnt + surroundOpenedCnt === surroundCells.length;

        /** ì—°ì‡„ ì˜¤í”ˆ ì‹¤í–‰ */
        if(surroundBombCnt === 0 && !allOpened){
            surroundCells.forEach(
                item => { if(!isGameOver)cellOpenRequest(item, true)}
            );
        }
    }



    function clickBomb(index){


        // ëª¨ë“ ì§€ë¢° ì—´ê¸°,
        // ì„ íƒí•œ ì§€ë¢°ëŠ” ë°±ê·¸ë¼ìš´ë“œ ë¹¨ê°„ìƒ‰,
        // ê¹ƒë°œì´ ê½‚í˜€ìˆì—ˆë‹¤ë©´ ê¹ƒë°œ ì—‘ìŠ¤ âŒ

        for(let i = 0; i < cellCnt; i++){
            if(bombArr.indexOf(i) > -1){
                const selectedCell = cellElement(i);
                selectedCell.innerHTML = 'ğŸ’£';
                selectedCell.classList.add('bomb');
            }
        }
        gameOver();
        // openBomb;
        // openOthers;
    }




</script>
</body>
</html>