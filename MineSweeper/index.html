<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>지뢰찾기</title>
    <style>
        body{
            padding: 50px;
            text-align: center;
        }
        table{
            border: 15px solid #DDD;
            border-collapse: collapse;
            margin: 0 auto;
        }
        td{
            padding:0;
            margin:0;
            border-spacing: 0;
            border:1px solid #DDD;
            border-collapse: collapse;
            height:40px;
            width:40px;
            text-align: center;
            cursor:pointer;
        }

        .bomb{
            background-color: red;
            /*color:#FFF;*/
        }
        .opened{
            background-color: #EEE;
            font-weight: bold;
            color:green;
        }
        .flagged{

        }
        #game-status{
            font-weight: bold;
            font-size: 2rem;
        }
    </style>
</head>
<body>
    <table>
        <tbody id="board"></tbody>
    </table>
    <p id="game-status"></p>
<script>

    /* 게임 세팅 */
    const BW = 10;
    const BH = 12;
    const bombCnt = 10;
    const cellCnt = BW * BH;



    /* 지뢰 정보 */

    let bombArr = [];

    (() =>{
        let tempArr = [];
        for(let i = 0; i < cellCnt; i++){
            tempArr[i] = i;
        }
        for(let i = 0; i < bombCnt; i++){
            const randNum = Math.floor(Math.random() * (cellCnt - i));
            bombArr.push(tempArr[randNum]);
            tempArr.splice(randNum,1);
        }
    })();



    /* 지뢰밭 정보 */

    let cellData = new Array(cellCnt);

    (()=>{
        /**
         * 위치 타입
         * 모서리 : 좌상, 우상, 좌하, 우하
         * 모서리를 제외한 줄 라인: 윗줄, 이랫줄, 왼줄, 오른줄
         * 기타 9칸
         */

        const firstRow = 0;
        const firstCol = 0;
        const lastRow = BH-1;
        const lastCol = BW-1;

        let position = '';

        for(let row = 0; row< BH; row ++){

            for(let col = 0; col< BW; col ++){

                const index = row * BW + col;

                if(row === firstRow){
                    if      (col === firstCol)  position = 'TOP_LEFT';
                    else if (col === lastCol)	position = 'TOP_RIGHT';
                    else                        position = 'TOP_LINE';
                }

                else if(row === lastRow){
                    if      (col === firstCol)  position = 'BOTTOM_LEFT';
                    else if (col === lastCol)	position = 'BOTTOM_RIGHT';
                    else                        position = 'BOTTOM_LINE';
                }

                else{
                    if      (col === firstCol)  position = 'LEFT_LINE';
                    else if (col === lastCol)	position = 'RIGHT_LINE';
                    else                        position = 'INSIDE';
                }

                cellData[index] = position;
            }
        }
    })();

    /* 지뢰밭 생성 */
    const boardTable = document.getElementById('board');

    let boardElement = '';
    (()=>{
        for(let i = 0; i< BH; i ++){
            boardElement +='<tr>';
            for(let j = 0; j< BW; j ++){
                const boxIndex = i*BW + j;
                boardElement +=`<td data-index="${boxIndex}"></td>`;
            }
            boardElement +='</tr>';
        }
        boardTable.innerHTML = boardElement;
    })();


    function getSurround(index){

        const position = cellData[index];
        let surround = [];

        const left = index - 1;
        const right = index + 1;
        const over = index - BW;
        const under = index + BW;

        Number.prototype.left = function () {return this - 1};
        Number.prototype.right = function () {return this + 1};

        switch (position) {
            case 'TOP_LEFT' :
                surround = [right, under, under.right()];
                break;

            case 'TOP_RIGHT' :
                surround = [left, under, under.left()];
                break;

            case 'BOTTOM_LEFT' :
                surround = [over, over.right(), right];
                break;

            case 'BOTTOM_RIGHT' :
                surround = [left, over, over.left()];
                break;

            case 'TOP_LINE' :
                surround = [left, right, under, under.left(), under.right()];
                break;

            case 'BOTTOM_LINE' :
                surround = [left, right, over, over.left(), over.right()];
                break;

            case 'LEFT_LINE' :
                surround = [over, over.right(), right, under, under.right()];
                break;

            case 'RIGHT_LINE' :
                surround = [over, over.left(), left, under, under.left()];
                break;

            default :
                surround = [over.left(), over, over.right(), left, right, under.left(), under, under.right()];

        }
        return surround;
    }



    let isGameOver = false;

    function isBomb(index) {
        return bombArr.some(bombIndex => bombIndex === index)
    }

    function gameOver(){
        isGameOver = true;
        document.getElementById('game-status').innerText = 'GAME OVER !!';
    }

    function hasClass(index, className) {
        return boardTable.querySelector(`[data-index="${index}"]`).classList.contains(className)
    }

    function checkIsGameOver (){

        let openedCellCnt = 0;
        let flaggedCellCnt = 0;

        for(let i = 0; i < cellCnt; i++){
            if(hasClass(i,'opened')){openedCellCnt++;}
        }

        for(let i = 0; i < cellCnt; i++){
            if(hasClass(i,'flagged')){flaggedCellCnt++;}
        }

        if(!isGameOver){
            isGameOver = (flaggedCellCnt === bombArr.length) && bombArr.length + openedCellCnt === cellCnt;
        }

        if(isGameOver){
            gameOver();
        }

        return(isGameOver);
    }


    /* 우클릭 이벤트 */
    window.oncontextmenu = (e) =>{
        if(e.target.nodeName !== 'TD') return;

        e.preventDefault();
        const selectedCell = e.target;

        let content = '🚩';
        if(selectedCell.textContent === '🚩'){
            content = '';
        }
        selectedCell.innerHTML = content;
        selectedCell.classList.toggle('flagged');

        checkIsGameOver();
    };


    /* 좌클릭 이벤트 */
    boardTable.addEventListener('click', function(e){

        // debugger;
        const index = Number(e.target.dataset.index);

        const isGameOver = checkIsGameOver();
        if(isGameOver){
            console.log('over')
            return;
        }else{
            console.log('not over')
            cellOpenRequest(index);
        }

        if( e.target.classList.contains('opened') ) return;
        if( e.target.classList.contains('flagged') ) return;


        if( isBomb(index) ) {console.log( isBomb(index) ? 'BOMB!!' : 'No bomb');} // 나중에 cellOpenRequest 안으로 이동 고려

        console.log('isGameOver :', isGameOver);

    });


    function cellOpenRequest(index, requester){

        checkIsGameOver();

        const selectedCell = boardTable.querySelector(`[data-index="${index}"]`);

        if(selectedCell.classList.contains('opened')) return;


        /** 오픈 가능 여부 판단  */
        /* 컴퓨터의 요청(자동 연쇄오픈)이면, 폭탄셀일 경우 열지 않음 */
        if(requester === 'computer'){
            if(isBomb(index)) return;
        }

        /** 오픈 실행  */

        /* 지뢰갯수 확인 */
        const surroundCells = getSurround(index);
        
        let surroundBombCnt = 0;
        let surroundOpenedCnt = 0;

        surroundCells.forEach(index => {
            if(bombArr.some(bombNum => bombNum === index)){
                surroundBombCnt ++;
            }

            const cell = boardTable.querySelector(`[data-index="${index}"]`);
            if(cell.classList.contains('opened')){
                surroundOpenedCnt++;
            }
        });


        if(isBomb(index)){
            selectedCell.innerHTML = '💣';
            selectedCell.classList.add('bomb');
            gameOver();
            return;
        }else{
            selectedCell.innerHTML = `${surroundBombCnt !== 0 ? surroundBombCnt : '' }`;
            selectedCell.classList.add('opened');
        }
        
        const allOpened = surroundBombCnt + surroundOpenedCnt === surroundCells.length;

        /** 연쇄 오픈 실행 */
        if(surroundBombCnt === 0 && !allOpened){
            surroundCells.forEach(
                item => { if(!isGameOver)cellOpenRequest(item, 'computer')}
            );
        }
    }

    function clickBomb(){
        // openBomb;
        // openOthers;
    }




</script>
</body>
</html>